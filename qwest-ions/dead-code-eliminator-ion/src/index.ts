#!/usr/bin/env bun
import { readFileSync, writeFileSync } from 'fs';
import { resolve } from 'path';
import { Command } from 'commander';
import { parse as parseYaml } from 'yaml';
import {
  ScanResultSchema,
  DeadCodeReportSchema,
  ConfigSchema,
  type ScanResult,
  type DeadCodeReport,
  type Config,
} from './types';
import { DeadCodeEliminator } from './eliminator';
import { logger } from './logger';

const program = new Command();

program
  .name('dead-code-eliminator-ion')
  .description('BMAD Ion for detecting unused code and orphaned dependencies')
  .version('1.0.0')
  .requiredOption('-i, --input <path>', 'Path to scan-results.json from Code Scanner Ion')
  .option('-o, --output <path>', 'Path to output dead-code-report.json (default: ./dead-code-report.json)')
  .option('-c, --config <path>', 'Path to config.yaml (default: ./config.yaml)')
  .option('--generate-scripts', 'Generate deletion scripts')
  .option('--verbose', 'Enable verbose logging')
  .parse(process.argv);

const options = program.opts();

async function main() {
  try {
    logger.section('Dead Code Eliminator Ion - BMAD Method');
    logger.info('Starting dead code analysis...');

    // Load config
    const configPath = resolve(options.config || './config.yaml');
    logger.info(`Loading config from: ${configPath}`);

    const configRaw = readFileSync(configPath, 'utf-8');
    const configData = parseYaml(configRaw);
    const config: Config = ConfigSchema.parse(configData);

    logger.success('Config loaded successfully');

    // Load scan results
    const inputPath = resolve(options.input);
    logger.info(`Loading scan results from: ${inputPath}`);

    const scanRaw = readFileSync(inputPath, 'utf-8');
    const scanData = JSON.parse(scanRaw);
    const scanResult: ScanResult = ScanResultSchema.parse(scanData);

    logger.success('Scan results loaded successfully');

    // Run analysis
    const eliminator = new DeadCodeEliminator(config, scanResult.project_root);
    const results = await eliminator.analyze(scanResult);

    // Generate deletion scripts
    const deletionScripts = options.generateScripts
      ? generateDeletionScripts(results.unusedFiles, config)
      : { bash: '', powershell: '', backup: '' };

    // Generate report
    logger.section('Generating Report');

    const filesAnalyzed = scanResult.findings?.files?.length || 0;
    const entitiesFound = results.unusedCode.length + results.unusedFiles.length;

    const report: DeadCodeReport = {
      generated_at: new Date().toISOString(),
      project_root: scanResult.project_root,
      analysis_summary: {
        files_analyzed: filesAnalyzed,
        entities_found: entitiesFound,
        unused_entities: results.unusedCode.length,
        unused_files: results.unusedFiles.length,
        unused_dependencies: results.unusedDependencies.length,
        disk_space_reclaimable: results.diskSpaceReclaimable,
      },
      unused_code: results.unusedCode,
      unused_files: results.unusedFiles,
      unused_dependencies: results.unusedDependencies,
      deletion_scripts: deletionScripts,
      recommendations: generateRecommendations(results, config),
    };

    // Validate output
    DeadCodeReportSchema.parse(report);

    // Write output
    const outputPath = resolve(options.output || './dead-code-report.json');
    writeFileSync(outputPath, JSON.stringify(report, null, 2));

    logger.success(`Report written to: ${outputPath}`);

    // Display summary
    displaySummary(report);

    logger.success('Dead code analysis complete!');
    process.exit(0);
  } catch (error) {
    logger.error('Fatal error during dead code analysis:');
    logger.error(error instanceof Error ? error.message : String(error));

    if (options.verbose && error instanceof Error) {
      logger.debug('Stack trace:');
      console.error(error.stack);
    }

    process.exit(1);
  }
}

function generateDeletionScripts(
  unusedFiles: Array<{ path: string; safe_to_delete: boolean }>,
  config: Config
): { bash: string; powershell: string; backup?: string } {
  const safeFiles = unusedFiles.filter(f => f.safe_to_delete);

  // Bash script
  const bashLines = [
    '#!/bin/bash',
    '# Generated by Dead Code Eliminator Ion',
    '# WARNING: Review carefully before executing!',
    '',
    'set -e',
    '',
    ...safeFiles.map(f => `# Delete: ${f.path}`),
    ...safeFiles.map(f => `rm "${f.path}"`),
  ];

  // PowerShell script
  const psLines = [
    '# Generated by Dead Code Eliminator Ion',
    '# WARNING: Review carefully before executing!',
    '',
    ...safeFiles.map(f => `# Delete: ${f.path}`),
    ...safeFiles.map(f => `Remove-Item -Path "${f.path}" -Force`),
  ];

  // Backup script (if enabled)
  const backupLines = config.safety.generate_backup_script
    ? [
        '#!/bin/bash',
        '# Backup script - run BEFORE deletion',
        '',
        'BACKUP_DIR="./dead-code-backup-$(date +%Y%m%d-%H%M%S)"',
        'mkdir -p "$BACKUP_DIR"',
        '',
        ...safeFiles.map(f => `cp "${f.path}" "$BACKUP_DIR/$(basename ${f.path})"`),
        '',
        'echo "Backup complete: $BACKUP_DIR"',
      ]
    : [];

  return {
    bash: bashLines.join('\n'),
    powershell: psLines.join('\n'),
    backup: backupLines.length > 0 ? backupLines.join('\n') : undefined,
  };
}

function generateRecommendations(results: any, config: Config): any[] {
  const recommendations: any[] = [];

  // Unused files
  if (results.unusedFiles.length > 0) {
    const totalSize = results.unusedFiles.reduce((sum: number, f: any) => sum + f.size, 0);

    recommendations.push({
      priority: results.unusedFiles.length > 10 ? 'high' : 'medium',
      category: 'Unused Files',
      description: `${results.unusedFiles.length} unused files detected. Safe to delete.`,
      affected_items: results.unusedFiles.map((f: any) => f.path),
      estimated_savings: formatBytes(totalSize),
    });
  }

  // Unused dependencies
  if (results.unusedDependencies.length > 0) {
    recommendations.push({
      priority: 'medium',
      category: 'Unused Dependencies',
      description: `${results.unusedDependencies.length} unused dependencies in package.json.`,
      affected_items: results.unusedDependencies.map((d: any) => d.name),
      estimated_savings: 'Varies (check node_modules size)',
    });
  }

  // Unused code entities
  if (results.unusedCode.length > 0) {
    const critical = results.unusedCode.filter((c: any) => c.priority === 'critical');

    if (critical.length > 0) {
      recommendations.push({
        priority: 'critical',
        category: 'Dead Code',
        description: `${critical.length} critical unused code entities found.`,
        affected_items: critical.map((c: any) => `${c.file}:${c.line}`),
        estimated_savings: 'Improves maintainability',
      });
    }
  }

  return recommendations;
}

function displaySummary(report: DeadCodeReport): void {
  logger.section('Analysis Summary');
  logger.info(`Files analyzed: ${report.analysis_summary.files_analyzed}`);
  logger.info(`Entities found: ${report.analysis_summary.entities_found}`);
  logger.info(`Unused entities: ${report.analysis_summary.unused_entities}`);
  logger.info(`Unused files: ${report.analysis_summary.unused_files}`);
  logger.info(`Unused dependencies: ${report.analysis_summary.unused_dependencies}`);
  logger.info(`Disk space reclaimable: ${formatBytes(report.analysis_summary.disk_space_reclaimable)}`);

  if (report.recommendations.length > 0) {
    logger.subsection('Top Recommendations');
    report.recommendations.slice(0, 5).forEach((rec, idx) => {
      logger.info(`${idx + 1}. [${rec.priority.toUpperCase()}] ${rec.description}`);
    });
  }
}

function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
}

main();
